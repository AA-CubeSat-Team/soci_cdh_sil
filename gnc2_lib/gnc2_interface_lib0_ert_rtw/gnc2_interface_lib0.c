/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * File: gnc2_interface_lib0.c
 *
 * Code generated for Simulink model 'gnc2_interface_lib0'.
 *
 * Model version                  : 1.8
 * Simulink Coder version         : 8.11 (R2016b) 25-Aug-2016
 * C/C++ source code generated on : Fri May 24 16:44:58 2019
 *
 * Target selection: ert.tlc
 * Embedded hardware selection: ARM Compatible->ARM 7
 * Code generation objectives:
 *    1. RAM efficiency
 *    2. Execution efficiency
 * Validation result: Not run
 */

#include "gnc2_interface_lib0.h"

/* Block signals and states (auto storage) */
DW rtDW;

/* Previous zero-crossings (trigger) states */
PrevZCX rtPrevZCX;

/* External inputs (root inport signals with auto storage) */
ExtU rtU;

/* External outputs (root outports fed by signals with auto storage) */
ExtY rtY;

/* Real-time model */
RT_MODEL rtM_;
RT_MODEL *const rtM = &rtM_;
extern void run_ecos(real_T rtu_n, real_T rtu_m, real_T rtu_p, real_T rtu_l,
                     real_T rtu_ncones, const real_T rtu_c[332], const real_T
                     rtu_Gjc[333], const real_T rtu_Gir[674], const real_T
                     rtu_Gpr[674], const real_T rtu_h[354], real_T rtu_q, const
                     real_T rtu_Ajc[333], const real_T rtu_Air[1278], const
                     real_T rtu_Apr[1278], const real_T rtu_b[117], real_T
                     rty_y[334]);

/* Forward declaration for local functions */
static void mohlfcjegdbijmoh_parse_ecos(const real_T xi[10], const real_T xf[7],
  const real_T J[9], const real_T EH[10000], const real_T BE[3000], const real_T
  ES[100], const real_T AR[100], real_T T_max, real_T w_max, real_T s_max,
  real_T s_min, real_T w_v, real_T c[332], real_T G[117528], real_T h[354],
  real_T A[38844], real_T b[117]);

/* Output and update for Simulink Function: '<S5>/call to ECOS SOCP solver (compiled C function)' */
void run_ecos(real_T rtu_n, real_T rtu_m, real_T rtu_p, real_T rtu_l, real_T
              rtu_ncones, const real_T rtu_c[332], const real_T rtu_Gjc[333],
              const real_T rtu_Gir[674], const real_T rtu_Gpr[674], const real_T
              rtu_h[354], real_T rtu_q, const real_T rtu_Ajc[333], const real_T
              rtu_Air[1278], const real_T rtu_Apr[1278], const real_T rtu_b[117],
              real_T rty_y[334])
{
  /* local block i/o variables */
  real_T rtb_sfun_ecos[334];
  int32_T rtb_DataTypeConversion;
  int32_T rtb_DataTypeConversion1;
  int32_T rtb_DataTypeConversion2;
  int32_T rtb_DataTypeConversion3;
  int32_T rtb_DataTypeConversion4;
  real_T rtb_TmpSignalConversionAtcOutpo[332];
  int32_T rtb_DataTypeConversion5[333];
  int32_T rtb_DataTypeConversion6[674];
  real_T rtb_TmpSignalConversionAthOutpo[354];
  int32_T rtb_DataTypeConversion7;
  int32_T rtb_DataTypeConversion8[333];
  real_T rtb_TmpSignalConversionAtbOutpo[117];
  int32_T i;

  /* DataTypeConversion: '<S9>/Data Type Conversion' incorporates:
   *  SignalConversion: '<S9>/TmpSignal ConversionAtnOutport1'
   */
  rtb_DataTypeConversion = (int32_T)floor(rtu_n);

  /* DataTypeConversion: '<S9>/Data Type Conversion1' incorporates:
   *  SignalConversion: '<S9>/TmpSignal ConversionAtmOutport1'
   */
  rtb_DataTypeConversion1 = (int32_T)floor(rtu_m);

  /* DataTypeConversion: '<S9>/Data Type Conversion2' incorporates:
   *  SignalConversion: '<S9>/TmpSignal ConversionAtpOutport1'
   */
  rtb_DataTypeConversion2 = (int32_T)floor(rtu_p);

  /* DataTypeConversion: '<S9>/Data Type Conversion3' incorporates:
   *  SignalConversion: '<S9>/TmpSignal ConversionAtlOutport1'
   */
  rtb_DataTypeConversion3 = (int32_T)floor(rtu_l);

  /* DataTypeConversion: '<S9>/Data Type Conversion4' incorporates:
   *  SignalConversion: '<S9>/TmpSignal ConversionAtnconesOutport1'
   */
  rtb_DataTypeConversion4 = (int32_T)floor(rtu_ncones);

  /* SignalConversion: '<S9>/TmpSignal ConversionAtcOutport1' */
  memcpy(&rtb_TmpSignalConversionAtcOutpo[0], &rtu_c[0], 332U * sizeof(real_T));

  /* DataTypeConversion: '<S9>/Data Type Conversion5' incorporates:
   *  SignalConversion: '<S9>/TmpSignal ConversionAtGjcOutport1'
   */
  for (i = 0; i < 333; i++) {
    rtb_DataTypeConversion5[i] = (int32_T)floor(rtu_Gjc[i]);
  }

  /* End of DataTypeConversion: '<S9>/Data Type Conversion5' */
  for (i = 0; i < 674; i++) {
    /* DataTypeConversion: '<S9>/Data Type Conversion6' incorporates:
     *  SignalConversion: '<S9>/TmpSignal ConversionAtGirOutport1'
     */
    rtb_DataTypeConversion6[i] = (int32_T)floor(rtu_Gir[i]);

    /* SignalConversion: '<S9>/TmpSignal ConversionAtGirOutport1' incorporates:
     *  SignalConversion: '<S9>/TmpSignal ConversionAtGprOutport1'
     */
    rtDW.rtb_TmpSignalConversionAtGprO_m[i] = rtu_Gpr[i];
  }

  /* SignalConversion: '<S9>/TmpSignal ConversionAthOutport1' */
  memcpy(&rtb_TmpSignalConversionAthOutpo[0], &rtu_h[0], 354U * sizeof(real_T));

  /* DataTypeConversion: '<S9>/Data Type Conversion7' incorporates:
   *  SignalConversion: '<S9>/TmpSignal ConversionAtqOutport1'
   */
  rtb_DataTypeConversion7 = (int32_T)floor(rtu_q);

  /* DataTypeConversion: '<S9>/Data Type Conversion8' incorporates:
   *  SignalConversion: '<S9>/TmpSignal ConversionAtAjcOutport1'
   */
  for (i = 0; i < 333; i++) {
    rtb_DataTypeConversion8[i] = (int32_T)floor(rtu_Ajc[i]);
  }

  /* End of DataTypeConversion: '<S9>/Data Type Conversion8' */
  for (i = 0; i < 1278; i++) {
    /* DataTypeConversion: '<S9>/Data Type Conversion9' incorporates:
     *  SignalConversion: '<S9>/TmpSignal ConversionAtAirOutport1'
     */
    rtDW.rtb_DataTypeConversion9_k[i] = (int32_T)floor(rtu_Air[i]);

    /* SignalConversion: '<S9>/TmpSignal ConversionAtAirOutport1' incorporates:
     *  SignalConversion: '<S9>/TmpSignal ConversionAtAprOutport1'
     */
    rtDW.rtb_TmpSignalConversionAtAprO_c[i] = rtu_Apr[i];
  }

  /* SignalConversion: '<S9>/TmpSignal ConversionAtbOutport1' */
  memcpy(&rtb_TmpSignalConversionAtbOutpo[0], &rtu_b[0], 117U * sizeof(real_T));

  /* S-Function (sfun_ecos): '<S9>/sfun_ecos' */
  callecos(rtb_DataTypeConversion, rtb_DataTypeConversion1,
           rtb_DataTypeConversion2, rtb_DataTypeConversion3,
           rtb_DataTypeConversion4, (real_T*)&rtb_TmpSignalConversionAtcOutpo[0],
           (int32_T*)&rtb_DataTypeConversion5[0], (int32_T*)
           &rtb_DataTypeConversion6[0], (real_T*)
           &rtDW.rtb_TmpSignalConversionAtGprO_m[0], (real_T*)
           &rtb_TmpSignalConversionAthOutpo[0], (int32_T*)
           &rtb_DataTypeConversion7, (int32_T*)&rtb_DataTypeConversion8[0],
           (int32_T*)&rtDW.rtb_DataTypeConversion9_k[0], (real_T*)
           &rtDW.rtb_TmpSignalConversionAtAprO_c[0], (real_T*)
           &rtb_TmpSignalConversionAtbOutpo[0], &rtb_sfun_ecos[0]);

  /* SignalConversion: '<S9>/TmpSignal ConversionAtyInport1' */
  memcpy(&rty_y[0], &rtb_sfun_ecos[0], 334U * sizeof(real_T));
}

/*
 * Function for MATLAB Function: '<S5>/SOLVE'
 * function [c,G,h,A,b] = parse_ecos(xi,xf,J,EH,BE,ES,AR,N,...
 *                                     ME,MI,T_max,w_max,s_max,s_min,w_v)
 */
static void mohlfcjegdbijmoh_parse_ecos(const real_T xi[10], const real_T xf[7],
  const real_T J[9], const real_T EH[10000], const real_T BE[3000], const real_T
  ES[100], const real_T AR[100], real_T T_max, real_T w_max, real_T s_max,
  real_T s_min, real_T w_v, real_T c[332], real_T G[117528], real_T h[354],
  real_T A[38844], real_T b[117])
{
  real_T u_max[30];
  real_T b_w_max[30];
  static const real_T d[100] = { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    1.0 };

  static const int8_T e[3320] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0 };

  static const int8_T f[2324] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

  static const real_T g[32] = { 0.70710678118654746, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.70710678118654746 };

  static const int8_T Hs[332] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0 };

  static const int8_T i[332] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0 };

  static const real_T z[332] = { -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.70710678118654746, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0,
    -0.0, -0.0 };

  static const real_T b_z[332] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.70710678118654746, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };

  int32_T i_0;
  real_T tmp[9];
  real_T tmp_0[30];
  int32_T i_1;

  /* '<S8>:1:279' u_max = T_max .* ones(N*3,1); */
  /* '<S8>:1:280' w_max = w_max .* ones(N*3,1); */
  for (i_0 = 0; i_0 < 30; i_0++) {
    u_max[i_0] = T_max;
    b_w_max[i_0] = w_max;
  }

  /* '<S8>:1:281' Nx = 10; */
  /* '<S8>:1:282' Nu = 3; */
  /* '<S8>:1:284' Hw  = [ kron(eye(N),[zeros(3,4) inv(J) zeros(3)]) zeros(3*N,N*(Nu+2*Nx)+2) ]; */
  fcbafcjedbimfkfc_inv(J, tmp);
  memset(&tmp_0[0], 0, 12U * sizeof(real_T));
  for (i_0 = 0; i_0 < 9; i_0++) {
    tmp_0[i_0 + 12] = tmp[i_0];
    tmp_0[i_0 + 21] = 0.0;
  }

  fkfkimopaimgfkno_kron(d, tmp_0, rtDW.dv3);
  memcpy(&rtDW.Hw[0], &rtDW.dv3[0], 3000U * sizeof(real_T));
  memset(&rtDW.Hw[3000], 0, 6960U * sizeof(real_T));

  /* '<S8>:1:285' Hu  = [ zeros(N*3,N*Nx) eye(N*3) zeros(N*3,2*N*Nx+2) ]; */
  mgdjecjmkfkndbim_eye(rtDW.dv2);
  memset(&rtDW.Hu[0], 0, 3000U * sizeof(real_T));
  memcpy(&rtDW.Hu[3000], &rtDW.dv2[0], 900U * sizeof(real_T));
  memset(&rtDW.Hu[3900], 0, 6060U * sizeof(real_T));

  /* '<S8>:1:286' Hv  = [ zeros(N*Nx) zeros(N*Nx,N*3) ... */
  /* '<S8>:1:287'         zeros(N*Nx,2) eye(N*Nx) zeros(N*Nx,N*Nx) ]; */
  nohdopppmohdjmoh_eye(rtDW.dv1);
  memset(&rtDW.Hv[0], 0, 13200U * sizeof(real_T));
  for (i_0 = 0; i_0 < 10000; i_0++) {
    rtDW.Hv[i_0 + 13200] = rtDW.dv1[i_0];
    rtDW.Hv[i_0 + 23200] = 0.0;
  }

  /* '<S8>:1:288' Hg  = [ zeros(1,N*(Nx+3)) 1 0 zeros(1,2*N*Nx) ]; */
  /* '<S8>:1:289' Hs  = [ zeros(1,N*(Nx+3)) 0 1 zeros(1,2*N*Nx) ]; */
  /* '<S8>:1:290' Hev = [ zeros(N*Nx,N*(2*Nx+3)+2) eye(N*Nx) ]; */
  nohdopppmohdjmoh_eye(rtDW.dv1);
  memset(&rtDW.Hev[0], 0, 23200U * sizeof(real_T));
  memcpy(&rtDW.Hev[23200], &rtDW.dv1[0], 10000U * sizeof(real_T));

  /*  Cost function */
  /* '<S8>:1:293' c   = [ zeros(N*(Nx+Nu),1); 1; 0; zeros(N*Nx,1); w_v*ones(N*Nx,1) ]; */
  memset(&c[0], 0, 130U * sizeof(real_T));
  c[130] = 1.0;
  c[131] = 0.0;
  for (i_0 = 0; i_0 < 100; i_0++) {
    c[i_0 + 132] = 0.0;
    c[i_0 + 232] = w_v;
  }

  /*  Equality constraints */
  /* '<S8>:1:295' A   = [ eye(Nx) repmat(zeros(Nx),1,N-1) zeros(Nx,N*(Nu+2*Nx)+2); */
  /* '<S8>:1:296'         EH-eye(size(EH)) BE zeros(N*Nx,1) ES eye(Nx*N) zeros(N*Nx,N*Nx); */
  /* '<S8>:1:297'         repmat(zeros(7,Nx),1,N-1) horzcat(eye(7),zeros(7,3)) zeros(7,N*(Nu+2*Nx)+2) ]; */
  nohdopppmohdjmoh_eye(rtDW.dv1);
  nohdopppmohdjmoh_eye(rtDW.dv0);
  for (i_0 = 0; i_0 < 332; i_0++) {
    for (i_1 = 0; i_1 < 10; i_1++) {
      A[i_1 + 117 * i_0] = e[10 * i_0 + i_1];
    }
  }

  for (i_0 = 0; i_0 < 100; i_0++) {
    for (i_1 = 0; i_1 < 100; i_1++) {
      A[(i_1 + 117 * i_0) + 10] = EH[100 * i_0 + i_1] - rtDW.dv1[100 * i_0 + i_1];
    }
  }

  for (i_0 = 0; i_0 < 30; i_0++) {
    memcpy(&A[i_0 * 117 + 11710], &BE[i_0 * 100], 100U * sizeof(real_T));
  }

  for (i_0 = 0; i_0 < 100; i_0++) {
    A[i_0 + 15220] = 0.0;
    A[i_0 + 15337] = ES[i_0];
    for (i_1 = 0; i_1 < 100; i_1++) {
      A[(i_1 + 117 * (i_0 + 132)) + 10] = rtDW.dv0[100 * i_0 + i_1];
      A[(i_1 + 117 * (i_0 + 232)) + 10] = 0.0;
    }
  }

  for (i_0 = 0; i_0 < 332; i_0++) {
    for (i_1 = 0; i_1 < 7; i_1++) {
      A[(i_1 + 117 * i_0) + 110] = f[7 * i_0 + i_1];
    }
  }

  /* '<S8>:1:298' b   = [xi; -AR; xf]; */
  memcpy(&b[0], &xi[0], 10U * sizeof(real_T));
  for (i_0 = 0; i_0 < 100; i_0++) {
    b[i_0 + 10] = -AR[i_0];
  }

  for (i_0 = 0; i_0 < 7; i_0++) {
    b[i_0 + 110] = xf[i_0];
  }

  /*  Inequality constraints */
  /* '<S8>:1:300' Glin    = [ Hw; -Hw; Hu; -Hu; Hs; -Hs; Hv-Hev; -Hv-Hev ]; */
  /* '<S8>:1:301' Gquad   = [ -Hg./sqrt(2); -Hu; Hg./sqrt(2) ]; */
  /* '<S8>:1:302' G       = [ Glin; Gquad ]; */
  for (i_0 = 0; i_0 < 332; i_0++) {
    for (i_1 = 0; i_1 < 30; i_1++) {
      G[i_1 + 354 * i_0] = rtDW.Hw[30 * i_0 + i_1];
      G[(i_1 + 354 * i_0) + 30] = -rtDW.Hw[30 * i_0 + i_1];
      G[(i_1 + 354 * i_0) + 60] = rtDW.Hu[30 * i_0 + i_1];
      G[(i_1 + 354 * i_0) + 90] = -rtDW.Hu[30 * i_0 + i_1];
    }

    G[120 + 354 * i_0] = Hs[i_0];
    G[121 + 354 * i_0] = i[i_0];
    for (i_1 = 0; i_1 < 100; i_1++) {
      G[(i_1 + 354 * i_0) + 122] = rtDW.Hv[100 * i_0 + i_1] - rtDW.Hev[100 * i_0
        + i_1];
      G[(i_1 + 354 * i_0) + 222] = -rtDW.Hv[100 * i_0 + i_1] - rtDW.Hev[100 *
        i_0 + i_1];
    }

    G[322 + 354 * i_0] = z[i_0];
    for (i_1 = 0; i_1 < 30; i_1++) {
      G[(i_1 + 354 * i_0) + 323] = -rtDW.Hu[30 * i_0 + i_1];
    }

    G[353 + 354 * i_0] = b_z[i_0];
  }

  /* '<S8>:1:303' hlin    = [ w_max; w_max; ...                */
  /* '<S8>:1:304'             u_max; u_max; ...                */
  /* '<S8>:1:305'             s_max; -s_min; ... */
  /* '<S8>:1:306'             zeros(N*Nx,1); zeros(N*Nx,1) ]; */
  /* '<S8>:1:307' hquad   = [ 1/sqrt(2); zeros(size(Hu,1),1); 1/sqrt(2) ]; */
  /* '<S8>:1:308' h       = [ hlin; hquad ]; */
  for (i_0 = 0; i_0 < 30; i_0++) {
    h[i_0] = b_w_max[i_0];
    h[i_0 + 30] = b_w_max[i_0];
    h[i_0 + 60] = u_max[i_0];
    h[i_0 + 90] = u_max[i_0];
  }

  h[120] = s_max;
  h[121] = -s_min;
  for (i_0 = 0; i_0 < 100; i_0++) {
    h[i_0 + 122] = 0.0;
    h[i_0 + 222] = 0.0;
  }

  memcpy(&h[322], &g[0], sizeof(real_T) << 5U);
}

/* Model step function */
void gnc2_interface_lib0_step(void)
{
  real_T ut[10];
  real_T u[6];
  real_T tspan[2];
  boolean_T x[10];
  real_T k2[10];
  real_T k3[10];
  int32_T low_i;
  int32_T high_i;
  int32_T mid_i;
  static const real_T J[9] = { 0.0338, -4.884E-5, -7.393E-5, -4.884E-5, 0.0346,
    7.124E-6, -7.393E-5, 7.124E-6, 0.0075 };

  real_T D[16];
  real_T x0[100];
  real_T wk[3];
  real_T V[16];
  real_T qb[40];
  int8_T flag;
  real_T ang;
  real_T sang;
  real_T t;
  int32_T d_k;
  real_T b_y;
  static const int8_T b_a[3] = { 0, 0, -1 };

  static const real_T d_y[16] = { 0.50000000000000011, 0.0, 0.0, 0.0, 0.0,
    0.50000000000000011, 0.0, 0.0, 0.0, 0.0, 0.50000000000000011, 0.0, 0.0, 0.0,
    0.0, 0.50000000000000011 };

  static const int8_T e_y[16] = { 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2
  };

  static const int8_T b_b[9] = { 1, 0, 0, 0, 1, 0, 0, 0, 1 };

  real_T exitcode[11];
  real_T xi[10];
  real_T xf[7];
  real_T y[334];
  real_T diff;
  real_T ES[100];
  real_T AR[100];
  real_T c[332];
  real_T h[354];
  real_T b[117];
  real_T Ajc[333];
  real_T Gjc[333];
  boolean_T rtb_Compare_k;
  boolean_T rtb_FixPtRelationalOperator;
  real_T rtb_x_opt_t[10];
  real_T rtb_U[30];
  real_T rtb_J[9];
  int32_T i;
  static const real_T tmp[9] = { 0.0338, -4.884E-5, -7.393E-5, -4.884E-5, 0.0346,
    7.124E-6, -7.393E-5, 7.124E-6, 0.0075 };

  real_T tmp_0[10];
  real_T tmp_1[9];
  real_T b_a_0[9];
  real_T tmp_2[9];
  real_T tmp_3[9];
  real_T rtb_J_0[3];
  real_T *V_0;
  int32_T exitg1;
  boolean_T exitg2;

  /* RelationalOperator: '<S6>/Compare' incorporates:
   *  Constant: '<S2>/Constant'
   *  Constant: '<S6>/Constant'
   *  Inport: '<Root>/sc_mode'
   *  RelationalOperator: '<S2>/Compare'
   */
  rtb_Compare_k = (rtU.sc_mode == 33.0);

  /* RelationalOperator: '<S3>/FixPt Relational Operator' incorporates:
   *  UnitDelay: '<S3>/Delay Input1'
   *
   * Block description for '<S3>/Delay Input1':
   *
   *  Store in Global RAM
   */
  rtb_FixPtRelationalOperator = ((int32_T)rtb_Compare_k > (int32_T)
    rtDW.DelayInput1_DSTATE);

  /* Outputs for Triggered SubSystem: '<S1>/gnc2_lib' incorporates:
   *  TriggerPort: '<S5>/Trigger'
   */
  if (rtb_FixPtRelationalOperator && (rtPrevZCX.gnc2_lib_Trig_ZCE != POS_ZCSIG))
  {
    /* MATLAB Function: '<S5>/INITIALIZE' incorporates:
     *  Inport: '<Root>/hw_Nms_init'
     *  Inport: '<Root>/quat_cmd'
     *  Inport: '<Root>/quat_in'
     *  Inport: '<Root>/sun_inertial_unit'
     *  Inport: '<Root>/w_body_cmd_radps'
     *  Inport: '<Root>/w_body_radps'
     */
    memcpy(&rtb_J[0], &tmp[0], 9U * sizeof(real_T));

    /* INIT_SOACER     */
    /*  */
    /*  SOACer's init function. */
    /*  */
    /*  T. Reynolds -- RAIN Lab */
    /* MATLAB Function 'gnc2_lib/INITIALIZE': '<S7>:1' */
    /*  Constraints */
    /* '<S7>:1:11' cB       = [ 0.0; 0.0; -1.0 ]; */
    /*  Camera boresight vector */
    /* '<S7>:1:12' amax     = deg2rad(60); */
    /*  FOV cone size */
    /* '<S7>:1:13' M        = [ sI*cB'+cB*sI'-(sI'*cB)*eye(3)   skew(sI)*cB; */
    /* '<S7>:1:14'              (skew(sI)*cB)'                  sI'*cB ] - cos(amax)*eye(4); */
    ang = (rtU.sun_inertial_unit[0] * 0.0 + rtU.sun_inertial_unit[1] * 0.0) +
      -rtU.sun_inertial_unit[2];

    /* 'skew:4' cross = [0 -a(3) a(2); */
    /* 'skew:5'          a(3) 0 -a(1); */
    /* 'skew:6'         -a(2) a(1) 0]; */
    /* 'skew:4' cross = [0 -a(3) a(2); */
    /* 'skew:5'          a(3) 0 -a(1); */
    /* 'skew:6'         -a(2) a(1) 0]; */
    /* '<S7>:1:15' Mt       = M + 2*eye(4); */
    /*  M_tilde */
    /*  compute matrix square root. Cannot use ME = sqrtm(Mt) since complex */
    /*  values are returned, and these are turned off for code generation */
    /* '<S7>:1:18' [V,D] = schur(Mt); */
    tmp_2[0] = 0.0;
    tmp_2[3] = -rtU.sun_inertial_unit[2];
    tmp_2[6] = rtU.sun_inertial_unit[1];
    tmp_2[1] = rtU.sun_inertial_unit[2];
    tmp_2[4] = 0.0;
    tmp_2[7] = -rtU.sun_inertial_unit[0];
    tmp_2[2] = -rtU.sun_inertial_unit[1];
    tmp_2[5] = rtU.sun_inertial_unit[0];
    tmp_2[8] = 0.0;
    tmp_3[0] = 0.0;
    tmp_3[3] = -rtU.sun_inertial_unit[2];
    tmp_3[6] = rtU.sun_inertial_unit[1];
    tmp_3[1] = rtU.sun_inertial_unit[2];
    tmp_3[4] = 0.0;
    tmp_3[7] = -rtU.sun_inertial_unit[0];
    tmp_3[2] = -rtU.sun_inertial_unit[1];
    tmp_3[5] = rtU.sun_inertial_unit[0];
    tmp_3[8] = 0.0;
    sang = 0.0;
    for (i = 0; i < 3; i++) {
      tmp_1[i] = rtU.sun_inertial_unit[i] * 0.0;
      b_a_0[i] = (real_T)b_a[i] * rtU.sun_inertial_unit[0];
      tmp_1[i + 3] = rtU.sun_inertial_unit[i] * 0.0;
      b_a_0[i + 3] = (real_T)b_a[i] * rtU.sun_inertial_unit[1];
      tmp_1[i + 6] = -rtU.sun_inertial_unit[i];
      b_a_0[i + 6] = (real_T)b_a[i] * rtU.sun_inertial_unit[2];
      sang += rtU.sun_inertial_unit[i] * (real_T)b_a[i];
      rtb_J_0[i] = -tmp_2[i + 6] + (tmp_2[i + 3] * 0.0 + tmp_2[i] * 0.0);
      wk[i] = -tmp_3[i + 6] + (tmp_3[i + 3] * 0.0 + tmp_3[i] * 0.0);
    }

    for (i = 0; i < 3; i++) {
      V[i << 2] = (tmp_1[3 * i] + b_a_0[3 * i]) - (real_T)b_b[3 * i] * ang;
      V[1 + (i << 2)] = (tmp_1[3 * i + 1] + b_a_0[3 * i + 1]) - (real_T)b_b[3 *
        i + 1] * ang;
      V[2 + (i << 2)] = (tmp_1[3 * i + 2] + b_a_0[3 * i + 2]) - (real_T)b_b[3 *
        i + 2] * ang;
      V[12 + i] = rtb_J_0[i];
      V[3 + (i << 2)] = wk[i];
    }

    V[15] = sang;
    for (i = 0; i < 4; i++) {
      D[i << 2] = (V[i << 2] - d_y[i << 2]) + (real_T)e_y[i << 2];
      D[1 + (i << 2)] = (V[(i << 2) + 1] - d_y[(i << 2) + 1]) + (real_T)e_y[(i <<
        2) + 1];
      D[2 + (i << 2)] = (V[(i << 2) + 2] - d_y[(i << 2) + 2]) + (real_T)e_y[(i <<
        2) + 2];
      D[3 + (i << 2)] = (V[(i << 2) + 3] - d_y[(i << 2) + 3]) + (real_T)e_y[(i <<
        2) + 3];
    }

    hdbaecbadjekpphd_xgehrd(D, wk);
    memcpy(&V[0], &D[0], sizeof(real_T) << 4U);
    baiegdbacjmgjekn_xungorghr(4, 1, 4, V, 1, wk, 1);
    biecbaaiaieclnop_eml_dlahqr(D, V);

    /* '<S7>:1:19' for k = 1:4 */
    /* '<S7>:1:22' ME  = V*D*V'; */
    /*  Exclusion constraint matrix */
    /* '<S7>:1:23' MI  = zeros(size(ME)); */
    /*  Inclusion constraint matrix */
    /* '<S7>:1:24' s_min   = 15; */
    /*  min allowable time */
    /* '<S7>:1:25' s_max   = 25; */
    /*  max allowable time */
    /*  Controller parameters */
    /* '<S7>:1:28' N       = 10; */
    /*  number of time nodes */
    /* '<S7>:1:29' Nx      = 10; */
    /*  number of states */
    /* '<S7>:1:30' Nu      = 3; */
    /*  number of controls */
    /*  spacecraft inertia matrix */
    /* '<S7>:1:33' J       = [ 0.0338    -4.884e-05 -7.393e-05; */
    /* '<S7>:1:34'             -4.884e-05  0.0346     7.124e-06; */
    /* '<S7>:1:35'             -7.393e-05  7.124e-06  0.0075 ]; */
    /*  kg m2 */
    /* '<S7>:1:36' T_max   = 2.3e-3; */
    /*  1mNm */
    /* '<S7>:1:37' w_max   = 0.1; */
    /*  rad/s */
    /* '<S7>:1:38' w_v     = 1e2; */
    /*  virtual control weight */
    /*  Initial trajectory */
    /* '<S7>:1:41' x0  = zeros(Nx,N); */
    memset(&x0[0], 0, 100U * sizeof(real_T));

    /* '<S7>:1:42' u0  = zeros(Nu,N); */
    /* '<S7>:1:43' s0  = s_max; */
    /* '<S7>:1:44' tau = linspace(0,1,N); */
    /* '<S7>:1:45' [qb,flag] = Q_SLERP(q0,qf); */
    /* Q_SLERP  */
    /*  */
    /*  Q_SLERP(q0,q1,tspan) Uses Spherical Linear intERPolation to  */
    /*  interpolate between two quaternions given the time space tspan.  */
    /*  Both q0 and q1 must be quaternions. */
    /*  */
    /*  T.Reynolds -- RAIN Lab. */
    /* '<S7>:1:73' N    = 10; */
    /* '<S7>:1:74' FLAG = int8(0); */
    flag = 0;

    /* '<S7>:1:76' if ( length(q0)~=4 || length(q1)~=4 ) */
    /*  Reshape inputs to be column vectors */
    /* '<S7>:1:83' q0  = reshape(q0, 4, 1); */
    /* '<S7>:1:84' q1  = reshape(q1, 4 ,1); */
    /*  Find angle between inputs */
    /* '<S7>:1:87' ang = acos(dot(q0,q1)); */
    ang = acos(((rtU.quat_in[0] * rtU.quat_cmd[0] + rtU.quat_in[1] *
                 rtU.quat_cmd[1]) + rtU.quat_in[2] * rtU.quat_cmd[2]) +
               rtU.quat_in[3] * rtU.quat_cmd[3]);

    /* '<S7>:1:88' if ( ang > pi ) */
    if (ang > 3.1415926535897931) {
      /* '<S7>:1:89' FLAG = int8(2); */
      flag = 2;

      /* '<S7>:1:90' qt   = repmat([1.0;0.0;0.0;0.0],1,N); */
      for (d_k = 0; d_k < 10; d_k++) {
        i = d_k << 2;
        qb[i] = 1.0;
        qb[i + 1] = 0.0;
        qb[i + 2] = 0.0;
        qb[i + 3] = 0.0;
      }
    } else {
      /* '<S7>:1:94' sang = sin(ang); */
      sang = sin(ang);

      /* '<S7>:1:95' qt   = zeros(4,N); */
      /* '<S7>:1:96' for k = 1:N */
      for (d_k = 0; d_k < 10; d_k++) {
        /* '<S7>:1:97' t       = (k-1)/(N-1); */
        t = ((1.0 + (real_T)d_k) - 1.0) / 9.0;

        /* '<S7>:1:98' qt(:,k) = (sin((1 - t)*ang)/sang).*q0 + (sin(t*ang)/sang).*q1; */
        b_y = sin((1.0 - t) * ang) / sang;
        t = sin(t * ang) / sang;
        qb[d_k << 2] = b_y * rtU.quat_in[0] + t * rtU.quat_cmd[0];
        qb[1 + (d_k << 2)] = b_y * rtU.quat_in[1] + t * rtU.quat_cmd[1];
        qb[2 + (d_k << 2)] = b_y * rtU.quat_in[2] + t * rtU.quat_cmd[2];
        qb[3 + (d_k << 2)] = b_y * rtU.quat_in[3] + t * rtU.quat_cmd[3];
      }
    }

    /* '<S7>:1:46' if ( flag == 0 ) */
    if (flag == 0) {
      /* '<S7>:1:47' for k = 1:N */
      for (low_i = 0; low_i < 10; low_i++) {
        /* '<S7>:1:48' wk = zeros(3,1); */
        /* '<S7>:1:49' for i = 1:3 */
        /* '<S7>:1:50' wk(i) = interp1([0 1],[w0(i) wf(i)],tau(k),'linear'); */
        ang = 0.1111111111111111 * (real_T)low_i;
        if (ang == 0.0) {
          wk[0] = rtU.w_body_radps[0];
        } else if (ang == 1.0) {
          wk[0] = rtU.w_body_cmd_radps[0];
        } else if (rtU.w_body_radps[0] == rtU.w_body_cmd_radps[0]) {
          wk[0] = rtU.w_body_radps[0];
        } else {
          wk[0] = (1.0 - ang) * rtU.w_body_radps[0] + ang *
            rtU.w_body_cmd_radps[0];
        }

        /* '<S7>:1:50' wk(i) = interp1([0 1],[w0(i) wf(i)],tau(k),'linear'); */
        ang = 0.1111111111111111 * (real_T)low_i;
        if (ang == 0.0) {
          wk[1] = rtU.w_body_radps[1];
        } else if (ang == 1.0) {
          wk[1] = rtU.w_body_cmd_radps[1];
        } else if (rtU.w_body_radps[1] == rtU.w_body_cmd_radps[1]) {
          wk[1] = rtU.w_body_radps[1];
        } else {
          wk[1] = (1.0 - ang) * rtU.w_body_radps[1] + ang *
            rtU.w_body_cmd_radps[1];
        }

        /* '<S7>:1:50' wk(i) = interp1([0 1],[w0(i) wf(i)],tau(k),'linear'); */
        ang = 0.1111111111111111 * (real_T)low_i;
        if (ang == 0.0) {
          wk[2] = rtU.w_body_radps[2];
        } else if (ang == 1.0) {
          wk[2] = rtU.w_body_cmd_radps[2];
        } else if (rtU.w_body_radps[2] == rtU.w_body_cmd_radps[2]) {
          wk[2] = rtU.w_body_radps[2];
        } else {
          wk[2] = (1.0 - ang) * rtU.w_body_radps[2] + ang *
            rtU.w_body_cmd_radps[2];
        }

        /* '<S7>:1:52' x0(:,k)   = [ qb(:,k); J*wk; hw0 ]; */
        for (i = 0; i < 3; i++) {
          rtb_J_0[i] = rtb_J[i + 6] * wk[2] + (rtb_J[i + 3] * wk[1] + rtb_J[i] *
            wk[0]);
        }

        x0[10 * low_i] = qb[low_i << 2];
        x0[1 + 10 * low_i] = qb[(low_i << 2) + 1];
        x0[2 + 10 * low_i] = qb[(low_i << 2) + 2];
        x0[3 + 10 * low_i] = qb[(low_i << 2) + 3];
        x0[4 + 10 * low_i] = rtb_J_0[0];
        x0[7 + 10 * low_i] = rtU.hw_Nms_init[0];
        x0[5 + 10 * low_i] = rtb_J_0[1];
        x0[8 + 10 * low_i] = rtU.hw_Nms_init[1];
        x0[6 + 10 * low_i] = rtb_J_0[2];
        x0[9 + 10 * low_i] = rtU.hw_Nms_init[2];

        /* '<S7>:1:53' u0(:,k)     = zeros(3,1); */
      }
    }

    /*  Initial state and control guess */
    /* '<S7>:1:58' X0   = reshape(x0,Nx*N,1); */
    /* '<S7>:1:59' U0   = reshape(u0,Nu*N,1); */
    memset(&rtb_U[0], 0, 30U * sizeof(real_T));

    /* MATLAB Function: '<S5>/SOLVE' incorporates:
     *  MATLAB Function: '<S5>/INITIALIZE'
     */
    /*                          c_size, Air_size, Ajc_size, Apr_size, b_size, ... */
    /*                          Gir_size, Gjc_size, Gpr_size, h_size, q_size) */
    /* SOLVE_STEP      */
    /*  */
    /*  SOACer's main function that solves the problem fully. */
    /*  */
    /*  T. Reynolds -- RAIN Lab */
    /* MATLAB Function 'gnc2_lib/SOLVE': '<S8>:1' */
    ang = 25.0;

    /* '<S8>:1:13' N  = 10; */
    /*  number of time nodes */
    /* '<S8>:1:14' Nx = 10; */
    /*  number of states */
    /* '<S8>:1:15' Nu = 3; */
    /*  number of controls */
    /* '<S8>:1:16' iter_max = 10; */
    /*  maximum global iterations */
    /*  Get problem sizes */
    /* '<S8>:1:19' c_size   = soac_params.c_size; */
    /* '<S8>:1:20' b_size   = soac_params.b_size; */
    /* '<S8>:1:21' h_size   = soac_params.h_size; */
    /* '<S8>:1:22' q_size   = soac_params.q_size; */
    /* '<S8>:1:23' Air_size = soac_params.Air_size; */
    /* '<S8>:1:24' Ajc_size = soac_params.Ajc_size; */
    /* '<S8>:1:25' Apr_size = soac_params.Apr_size; */
    /* '<S8>:1:26' Gir_size = soac_params.Gir_size; */
    /* '<S8>:1:27' Gjc_size = soac_params.Gjc_size; */
    /* '<S8>:1:28' Gpr_size = soac_params.Gpr_size; */
    /* '<S8>:1:29' l_dim    = soac_params.l_dim; */
    /* '<S8>:1:30' soc_dim  = soac_params.soc_dim; */
    /* '<S8>:1:31' n        = c_size; */
    /*  primal variables */
    /* '<S8>:1:32' m        = h_size; */
    /*  number of inequality constraints */
    /* '<S8>:1:33' p        = b_size; */
    /*  number of equality constraints */
    /* '<S8>:1:34' l        = l_dim; */
    /*  dimension of linear cone */
    /* '<S8>:1:35' ncones   = q_size; */
    /*  number of SOCs */
    /* '<S8>:1:36' q        = soc_dim; */
    /*  dimension of the ith SOC */
    /* '<S8>:1:37' exitcode = zeros(iter_max+1,1); */
    memset(&exitcode[0], 0, 11U * sizeof(real_T));

    /* '<S8>:1:38' time     = zeros(iter_max,1); */
    /*  Initial and final conditions stored in initial guess X */
    /* '<S8>:1:41' xi = X(1:Nx); */
    for (i = 0; i < 10; i++) {
      rtb_x_opt_t[i] = 0.0;
      xi[i] = x0[i];
    }

    /* '<S8>:1:42' xf = X(Nx*(N-1)+(1:7)); */
    for (i = 0; i < 7; i++) {
      xf[i] = x0[i + 90];
    }

    /*  LEAVE THIS AS 7 */
    /* '<S8>:1:44' for k = 1:iter_max */
    d_k = 1;
    low_i = 0;
    exitg2 = false;
    while ((!exitg2) && (low_i < 10)) {
      d_k = low_i + 1;

      /*  discretize */
      /* '<S8>:1:47' [EH,BE,ES,AR] = foh(X,U,s,N,Nx,Nu,J); */
      pphlkfcjfcjmiekf_foh(x0, rtb_U, ang, rtb_J, rtDW.EH, rtDW.BE, ES, AR);

      /*  parse for ECOS */
      /* '<S8>:1:50' [c,G,h,A,b] = parse_ecos(xi,xf,J,EH,BE,ES,AR,N,... */
      /* '<S8>:1:51'                                         ME,MI,T_max,w_max,s_max,s_min,w_v); */
      mohlfcjegdbijmoh_parse_ecos(xi, xf, rtb_J, rtDW.EH, rtDW.BE, ES, AR,
        0.0023, 0.1, 25.0, 15.0, 100.0, c, rtDW.G, h, rtDW.A, b);

      /*  put A and G in compressed column storage */
      /* '<S8>:1:54' [Air,Ajc,Apr] = convert_to_CCS(A,Air_size); */
      mgdbiecbmohlcjmo_convert_to_CCS(rtDW.A, rtDW.Air, Ajc, rtDW.Apr);

      /* '<S8>:1:55' [Gir,Gjc,Gpr] = convert_to_CCS(G,Gir_size); */
      knohcbaaphlnkfcb_convert_to_CCS(rtDW.G, rtDW.Gir, Gjc, rtDW.Gpr);

      /*  call to ECOS */
      /* '<S8>:1:58' y = run_ecos(n,m,p,l,ncones,c(1:c_size),... */
      /* '<S8>:1:59'                     Gjc(1:Gjc_size),Gir(1:Gir_size),Gpr(1:Gpr_size),... */
      /* '<S8>:1:60'                     h(1:h_size),q(1:q_size),... */
      /* '<S8>:1:61'                     Ajc(1:Ajc_size),Air(1:Air_size),Apr(1:Apr_size),... */
      /* '<S8>:1:62'                     b(1:b_size)); */
      run_ecos(332.0, 354.0, 117.0, 322.0, 1.0, c, Gjc, rtDW.Gir, rtDW.Gpr, h,
               32.0, Ajc, rtDW.Air, rtDW.Apr, b, y);

      /*  check convergence & update solution */
      /* '<S8>:1:65' diff        = norm(X - y(1:N*Nx),1); */
      for (i = 0; i < 100; i++) {
        ES[i] = x0[i] - y[i];
        x0[i] = y[i];
      }

      diff = nglnimohlfkfphln_norm(ES);

      /*  difference in state vector */
      /* '<S8>:1:66' X           = y(1:N*Nx); */
      /* '<S8>:1:67' U           = y(N*Nx+1:N*(Nx+Nu)); */
      memcpy(&rtb_U[0], &y[100], 30U * sizeof(real_T));

      /* '<S8>:1:68' s           = y(N*(Nx+Nu)+2); */
      ang = y[131];

      /* '<S8>:1:69' V           = y(N*(Nx+Nu)+3:N*(2*Nx+Nu)+1); */
      V_0 = &y[132];

      /* '<S8>:1:70' exitcode(k) = y(c_size+1); */
      exitcode[low_i] = y[332];

      /* '<S8>:1:71' time(k)     = y(c_size+2); */
      rtb_x_opt_t[low_i] = y[333];

      /*  if one of the exitcodes indicates failue, the final */
      /*  entry in exitcode is set to -1 to indicate this, and the */
      /*  solution should not be used */
      /* '<S8>:1:75' if (exitcode(k) ~= 0) */
      if (exitcode[low_i] != 0.0) {
        /* '<S8>:1:76' exitcode(iter_max+1) = -1; */
        exitcode[10] = -1.0;
      }

      /* '<S8>:1:79' if ( (norm(V,1) < 1e-5) && (diff < 1e-1) ) */
      if ((gdbifkfcbaimlfkn_norm(&y[132]) < 1.0E-5) && (diff < 0.1)) {
        /*  exit for loop since we've converged */
        exitg2 = true;
      } else {
        low_i++;
      }
    }

    /*  Sanity checks on the solution if we hit the max iterations */
    /* '<S8>:1:87' if (k==iter_max) */
    if ((d_k == 10) && (exitcode[10] != -1.0)) {
      /*  hit max global iterations */
      /* '<S8>:1:88' if (exitcode(iter_max+1) ~= -1 ) */
      /* '<S8>:1:89' if (norm(V,1) > 1e-5) */
      if (gdbifkfcbaimlfkn_norm(V_0) > 1.0E-5) {
        /* '<S8>:1:90' exitcode(iter_max+1) = 3; */
        exitcode[10] = 3.0;

        /*  does not clash with ECOS exitcodes */
      } else {
        if (diff > 1.0E-5) {
          /* '<S8>:1:91' elseif (diff>1e-5) */
          /* '<S8>:1:92' exitcode(iter_max+1) = 4; */
          exitcode[10] = 4.0;
        }
      }
    }

    /* Outport: '<Root>/exitcode' incorporates:
     *  MATLAB Function: '<S5>/SOLVE'
     *  SignalConversion: '<S5>/OutportBufferForexitcode'
     */
    memcpy(&rtY.exitcode[0], &exitcode[0], 11U * sizeof(real_T));

    /* Outport: '<Root>/s' incorporates:
     *  MATLAB Function: '<S5>/SOLVE'
     *  SignalConversion: '<S5>/OutportBufferForfinal_time_s'
     */
    rtY.s = ang;

    /* Outport: '<Root>/U' incorporates:
     *  SignalConversion: '<S5>/OutportBufferForopt_ctrl_Nm'
     */
    memcpy(&rtY.U[0], &rtb_U[0], 30U * sizeof(real_T));

    /* Outport: '<Root>/X' incorporates:
     *  SignalConversion: '<S5>/OutportBufferForopt_state'
     */
    memcpy(&rtY.X_h[0], &x0[0], 100U * sizeof(real_T));

    /* Outport: '<Root>/time' incorporates:
     *  MATLAB Function: '<S5>/SOLVE'
     *  SignalConversion: '<S5>/OutportBufferForsol_times_s'
     */
    memcpy(&rtY.time[0], &rtb_x_opt_t[0], 10U * sizeof(real_T));
  }

  rtPrevZCX.gnc2_lib_Trig_ZCE = rtb_FixPtRelationalOperator;

  /* End of Outputs for SubSystem: '<S1>/gnc2_lib' */

  /* Sum: '<S1>/Sum' incorporates:
   *  Inport: '<Root>/GPS_epoch'
   *  Inport: '<Root>/GPS_time'
   */
  diff = rtU.GPS_time[0] - rtU.GPS_epoch[0];

  /* Delay: '<S1>/Resettable Delay' incorporates:
   *  Inport: '<Root>/hw_Nms_init'
   *  Inport: '<Root>/quat_in'
   *  Inport: '<Root>/w_body_radps'
   *  SignalConversion: '<S1>/TmpSignal ConversionAtResettable DelayInport3'
   */
  if (rtb_FixPtRelationalOperator && (rtPrevZCX.ResettableDelay_Reset_ZCE !=
       POS_ZCSIG)) {
    rtDW.icLoad = 1U;
  }

  rtPrevZCX.ResettableDelay_Reset_ZCE = rtb_FixPtRelationalOperator;
  if (rtDW.icLoad != 0) {
    rtDW.ResettableDelay_DSTATE[0] = rtU.quat_in[0];
    rtDW.ResettableDelay_DSTATE[1] = rtU.quat_in[1];
    rtDW.ResettableDelay_DSTATE[2] = rtU.quat_in[2];
    rtDW.ResettableDelay_DSTATE[3] = rtU.quat_in[3];
    rtDW.ResettableDelay_DSTATE[4] = rtU.w_body_radps[0];
    rtDW.ResettableDelay_DSTATE[7] = rtU.hw_Nms_init[0];
    rtDW.ResettableDelay_DSTATE[5] = rtU.w_body_radps[1];
    rtDW.ResettableDelay_DSTATE[8] = rtU.hw_Nms_init[1];
    rtDW.ResettableDelay_DSTATE[6] = rtU.w_body_radps[2];
    rtDW.ResettableDelay_DSTATE[9] = rtU.hw_Nms_init[2];
  }

  /* MATLAB Function: '<S1>/INTERP' incorporates:
   *  Delay: '<S1>/Resettable Delay'
   */
  /*  parameters */
  /* MATLAB Function 'gnc2_interface_lib/INTERP': '<S4>:1' */
  /* '<S4>:1:5' N  = 10; */
  /* '<S4>:1:6' ut = linspace(0,s_opt,N); */
  ut[9] = rtY.s;
  ut[0] = 0.0;
  if ((rtY.s < 0.0) && (fabs(rtY.s) > 8.9884656743115785E+307)) {
    ang = rtY.s / 9.0;
    for (low_i = 0; low_i < 8; low_i++) {
      ut[1 + low_i] = (1.0 + (real_T)low_i) * ang;
    }
  } else {
    ang = rtY.s / 9.0;
    for (d_k = 0; d_k < 8; d_k++) {
      ut[1 + d_k] = (1.0 + (real_T)d_k) * ang;
    }
  }

  /*  soac_params.N = 10 */
  /* '<S4>:1:7' k  = sum(t>ut); */
  for (i = 0; i < 10; i++) {
    x[i] = (diff > ut[i]);
  }

  ang = x[0];
  for (d_k = 0; d_k < 9; d_k++) {
    ang += (real_T)x[d_k + 1];
  }

  /*  current interval */
  /* '<S4>:1:8' J  = [ 0.0338    -4.884e-05 -7.393e-05; */
  /* '<S4>:1:9'     -4.884e-05  0.0346     7.124e-06; */
  /* '<S4>:1:10'     -7.393e-05  7.124e-06  0.0075 ]; */
  /*  kg m2 */
  /*  Output final state/control if we are beyond the final maneuver time */
  /* '<S4>:1:13' if ((s_opt>0)&&(t>=s_opt)) */
  if ((rtY.s > 0.0) && (diff >= rtY.s)) {
    /* '<S4>:1:14' u_opt_t = zeros(3,1); */
    wk[0] = 0.0;
    wk[1] = 0.0;
    wk[2] = 0.0;

    /* '<S4>:1:15' x_opt_t = [ x_opt(1:4,N); J\x_opt(5:7,N); x_opt(8:10,N) ]; */
    ohdbngdjimopdbim_mldivide(J, &rtY.X_h[94], rtb_J_0);
    rtb_x_opt_t[0] = rtY.X_h[90];
    rtb_x_opt_t[1] = rtY.X_h[91];
    rtb_x_opt_t[2] = rtY.X_h[92];
    rtb_x_opt_t[3] = rtY.X_h[93];
    rtb_x_opt_t[4] = rtb_J_0[0];
    rtb_x_opt_t[7] = rtY.X_h[97];
    rtb_x_opt_t[5] = rtb_J_0[1];
    rtb_x_opt_t[8] = rtY.X_h[98];
    rtb_x_opt_t[6] = rtb_J_0[2];
    rtb_x_opt_t[9] = rtY.X_h[99];
  } else {
    /*  Otherwise integrate to current state and interpolate for current control */
    /* '<S4>:1:20' if ((k>0) && (s_opt>0)) */
    if ((ang > 0.0) && (rtY.s > 0.0)) {
      /* '<S4>:1:21' um      = u_opt(3*(k-1)+(1:3)); */
      /* '<S4>:1:22' up      = u_opt(3*k+(1:3)); */
      /* '<S4>:1:23' u       = [reshape(um,3,1) reshape(up,3,1)]; */
      u[0] = rtY.U[(int32_T)((ang - 1.0) * 3.0 + 1.0) - 1];
      u[3] = rtY.U[(int32_T)(3.0 * ang + 1.0) - 1];
      u[1] = rtY.U[(int32_T)((ang - 1.0) * 3.0 + 2.0) - 1];
      u[4] = rtY.U[(int32_T)(3.0 * ang + 2.0) - 1];
      u[2] = rtY.U[(int32_T)((ang - 1.0) * 3.0 + 3.0) - 1];
      u[5] = rtY.U[(int32_T)(3.0 * ang + 3.0) - 1];

      /* '<S4>:1:24' tspan   = [ ut(k); ut(k+1) ]; */
      tspan[0] = ut[(int32_T)ang - 1];
      tspan[1] = ut[(int32_T)(ang + 1.0) - 1];

      /*  step integrator for x_opt_t */
      /* '<S4>:1:27' x_opt_t = rk4_one_step(t,x_last,u,J,tspan,soac_params.sample_time_s); */
      /* '<S4>:1:45' k1 = deriv(t    ,x       ,u,J,tspan); */
      imglnglnfkngcbai_deriv(diff, rtDW.ResettableDelay_DSTATE, u, J, tspan, xi);

      /* '<S4>:1:46' k2 = deriv(t+h/2,x+h/2*k1,u,J,tspan); */
      for (i = 0; i < 10; i++) {
        rtb_x_opt_t[i] = 0.05 * xi[i] + rtDW.ResettableDelay_DSTATE[i];
      }

      imglnglnfkngcbai_deriv(diff + 0.05, rtb_x_opt_t, u, J, tspan, k2);

      /* '<S4>:1:47' k3 = deriv(t+h/2,x+h/2*k2,u,J,tspan); */
      for (i = 0; i < 10; i++) {
        rtb_x_opt_t[i] = 0.05 * k2[i] + rtDW.ResettableDelay_DSTATE[i];
      }

      imglnglnfkngcbai_deriv(diff + 0.05, rtb_x_opt_t, u, J, tspan, k3);

      /* '<S4>:1:48' k4 = deriv(t+h  ,x+h*k3  ,u,J,tspan); */
      /* '<S4>:1:50' x = (x+h/6*(k1+2*k2+2*k3+k4)); */
      for (i = 0; i < 10; i++) {
        rtb_x_opt_t[i] = 0.1 * k3[i] + rtDW.ResettableDelay_DSTATE[i];
      }

      imglnglnfkngcbai_deriv(diff + 0.1, rtb_x_opt_t, u, J, tspan, tmp_0);
      for (i = 0; i < 10; i++) {
        rtb_x_opt_t[i] = (((2.0 * k2[i] + xi[i]) + 2.0 * k3[i]) + tmp_0[i]) *
          0.016666666666666666 + rtDW.ResettableDelay_DSTATE[i];
      }

      /*      x_opt_t = [ x_opt_t(1:4); J\x_opt_t(5:7); x_opt_t(8:10) ]; */
      /*      x_opt_t = [ x_opt(1:4,k); x_opt(5:7,k); x_opt(8:10,k) ]; */
      /*  interpolate for control */
      /* '<S4>:1:32' u_opt_t = zeros(3,1); */
      /* '<S4>:1:33' for i = 1:3 */
      for (d_k = 0; d_k < 3; d_k++) {
        /* '<S4>:1:34' u_opt_t(i) = interp1(ut,u_opt(i,:),t,'linear'); */
        memcpy(&k2[0], &ut[0], 10U * sizeof(real_T));
        for (i = 0; i < 10; i++) {
          xi[i] = rtY.U[3 * i + d_k];
        }

        ang = (rtNaN);
        low_i = 1;
        do {
          exitg1 = 0;
          if (low_i < 11) {
            if (rtIsNaN(ut[low_i - 1])) {
              exitg1 = 1;
            } else {
              low_i++;
            }
          } else {
            if (ut[1] < 0.0) {
              for (low_i = 0; low_i < 5; low_i++) {
                sang = k2[low_i];
                k2[low_i] = k2[9 - low_i];
                k2[9 - low_i] = sang;
              }

              for (low_i = 0; low_i < 5; low_i++) {
                sang = xi[low_i];
                xi[low_i] = xi[9 - low_i];
                xi[9 - low_i] = sang;
              }
            }

            if ((!rtIsNaN(diff)) && (!(diff > k2[9])) && (!(diff < k2[0]))) {
              low_i = 1;
              i = 2;
              high_i = 10;
              while (high_i > i) {
                mid_i = (low_i + high_i) >> 1;
                if (diff >= k2[mid_i - 1]) {
                  low_i = mid_i;
                  i = mid_i + 1;
                } else {
                  high_i = mid_i;
                }
              }

              ang = (diff - k2[low_i - 1]) / (k2[low_i] - k2[low_i - 1]);
              if (ang == 0.0) {
                ang = xi[low_i - 1];
              } else if (ang == 1.0) {
                ang = xi[low_i];
              } else if (xi[low_i - 1] == xi[low_i]) {
                ang = xi[low_i - 1];
              } else {
                ang = (1.0 - ang) * xi[low_i - 1] + ang * xi[low_i];
              }
            }

            exitg1 = 1;
          }
        } while (exitg1 == 0);

        wk[d_k] = ang;
      }
    } else {
      /* '<S4>:1:36' else */
      /* '<S4>:1:37' u_opt_t = zeros(3,1); */
      wk[0] = 0.0;
      wk[1] = 0.0;
      wk[2] = 0.0;

      /* '<S4>:1:38' x_opt_t = x_last; */
      memcpy(&rtb_x_opt_t[0], &rtDW.ResettableDelay_DSTATE[0], 10U * sizeof
             (real_T));
    }
  }

  /* End of MATLAB Function: '<S1>/INTERP' */

  /* Outport: '<Root>/command_torque' */
  rtY.command_torque[0] = wk[0];
  rtY.command_torque[1] = wk[1];
  rtY.command_torque[2] = wk[2];

  /* Update for UnitDelay: '<S3>/Delay Input1'
   *
   * Block description for '<S3>/Delay Input1':
   *
   *  Store in Global RAM
   */
  rtDW.DelayInput1_DSTATE = rtb_Compare_k;

  /* Update for Delay: '<S1>/Resettable Delay' */
  rtDW.icLoad = 0U;

  /* Outport: '<Root>/command_state' */
  memcpy(&rtY.command_state[0], &rtb_x_opt_t[0], 10U * sizeof(real_T));

  /* Update for Delay: '<S1>/Resettable Delay' */
  memcpy(&rtDW.ResettableDelay_DSTATE[0], &rtb_x_opt_t[0], 10U * sizeof(real_T));
}

/* Model initialize function */
void gnc2_interface_lib0_initialize(void)
{
  /* Registration code */

  /* initialize non-finites */
  rt_InitInfAndNaN(sizeof(real_T));
  rtPrevZCX.ResettableDelay_Reset_ZCE = POS_ZCSIG;

  /* InitializeConditions for Delay: '<S1>/Resettable Delay' */
  rtDW.icLoad = 1U;

  /* SystemInitialize for Triggered SubSystem: '<S1>/gnc2_lib' */
  rtPrevZCX.gnc2_lib_Trig_ZCE = ZERO_ZCSIG;

  /* End of SystemInitialize for SubSystem: '<S1>/gnc2_lib' */
}

/* Model terminate function */
void gnc2_interface_lib0_terminate(void)
{
  /* (no terminate code required) */
}

/*
 * File trailer for generated code.
 *
 * [EOF]
 */
